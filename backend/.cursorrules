# CodeRacer Backend - Go Rules

## Language & Framework

- Use Go 1.21+
- Follow Go standard library patterns
- Use Gin framework for HTTP routing
- Use GORM for database operations
- Use Redis for caching and session management

## Code Style - CRITICAL RULES

- **FUNCTION SIZE**: Keep functions under 30 lines. If longer, break into smaller functions
- **FUNCTION NAMING**: Use descriptive, action-oriented names (e.g., `validateUserInput`, `processPayment`, `sendNotification`)
- **VARIABLE NAMING**: Use clear, descriptive names that explain purpose (e.g., `userID`, `isAuthenticated`, `maxRetryCount`)
- **AVOID**: Generic names like `data`, `result`, `temp`, `val`, `obj`
- Follow Go naming conventions (camelCase for private, PascalCase for public)
- Use interfaces for dependency injection
- Prefer composition over inheritance

## Function Design Principles

- **Single Responsibility**: Each function should do ONE thing well
- **Clear Purpose**: Function name should clearly indicate what it does
- **Small Size**: Break large functions into smaller, focused functions
- **Descriptive Parameters**: Use meaningful parameter names
- **Return Clarity**: Return values should be self-explanatory

## Variable Naming Standards

- **Boolean**: Use `is`, `has`, `can`, `should` prefixes (e.g., `isLoggedIn`, `hasPermission`, `canEdit`)
- **Counters**: Use descriptive names (e.g., `retryCount`, `attemptNumber`, `userCount`)
- **IDs**: Always include type (e.g., `userID`, `matchID`, `sessionID`)
- **Collections**: Use plural forms (e.g., `users`, `matches`, `sessions`)
- **Temporary**: Even temp variables need meaningful names (e.g., `currentUser`, `nextMatch`)

## Constants & Magic Values - CRITICAL RULES

- **NO MAGIC NUMBERS**: Define constants for all numeric values (e.g., `const MaxRetryCount = 3`, `const DefaultTimeout = 30`)
- **NO MAGIC STRINGS**: Define constants for all string literals (e.g., `const StatusActive = "active"`, `const ErrorMessage = "invalid input"`)
- **CONSTANT NAMING**: Use descriptive names in UPPER_CASE (e.g., `MAX_CONNECTION_RETRIES`, `DEFAULT_SESSION_TIMEOUT`)
- **GROUP RELATED CONSTANTS**: Use const blocks to group related constants
- **CONFIG VALUES**: Move configuration values to config files, not hardcoded constants
- **EXCEPTIONS**: Only allow magic numbers for obvious cases (e.g., `len(slice)`, `i++`, `0`, `1`)

### Examples:

```go
// ❌ BAD - Magic numbers and strings
if retryCount > 3 {
    return errors.New("failed")
}

// ✅ GOOD - Named constants
const (
    MAX_RETRY_ATTEMPTS = 3
    ERROR_MESSAGE_FAILED = "failed"
)

if retryCount > MAX_RETRY_ATTEMPTS {
    return errors.New(ERROR_MESSAGE_FAILED)
}
```

## Error Handling

- Always handle errors explicitly
- Use custom error types when needed
- Log errors with context using structured logging
- Return errors from functions, don't panic unless absolutely necessary

## Database

- Use migrations for schema changes
- Always use transactions for multi-table operations
- Use prepared statements to prevent SQL injection
- Follow repository pattern for data access

## WebSocket

- Handle connection cleanup properly
- Use channels for communication between goroutines
- Implement proper reconnection logic
- Log WebSocket events for debugging

## Testing & Testability - CRITICAL RULES

- **TESTABLE FUNCTIONS**: All functions must be designed with testability in mind
- **DEPENDENCY INJECTION**: Use interfaces for all external dependencies (database, HTTP clients, etc.)
- **PURE FUNCTIONS**: Prefer pure functions that don't depend on global state
- **SINGLE RESPONSIBILITY**: Each function should have one clear purpose for easier testing
- **SMALL FUNCTIONS**: Keep functions small (< 30 lines) for easier unit testing
- **NO SIDE EFFECTS**: Minimize side effects, make them explicit and testable
- **MOCKABLE DEPENDENCIES**: All external dependencies must be mockable via interfaces
- **TESTABLE ERROR HANDLING**: Error conditions must be easily testable
- **DETERMINISTIC BEHAVIOR**: Functions should produce predictable outputs for given inputs

### Testability Guidelines:

- **Unit Tests**: Write unit tests for all business logic functions
- **Table-Driven Tests**: Use table-driven tests for functions with multiple scenarios
- **Mock External Dependencies**: Mock database, HTTP clients, file system, etc.
- **Test Coverage**: Aim for high test coverage (>80%)
- **Integration Tests**: Write integration tests for critical workflows
- **Test Data**: Use test fixtures and factories for consistent test data
- **Test Isolation**: Each test should be independent and not affect others

### Examples:

```go
// ❌ BAD - Hard to test (global state, side effects)
var db *gorm.DB

func ProcessUser(userID string) error {
    user := db.Find(userID) // Global dependency
    // ... processing
    db.Save(user) // Side effect
    return nil
}

// ✅ GOOD - Testable (dependency injection, pure function)
type UserProcessor struct {
    userRepo UserRepository
}

func (p *UserProcessor) ProcessUser(userID string) error {
    user, err := p.userRepo.FindByID(userID)
    if err != nil {
        return err
    }
    // ... processing
    return p.userRepo.Save(user)
}
```

## Security

- Validate all input data
- Use JWT for authentication
- Implement proper CORS policies
- Sanitize user inputs

## Performance

- Use connection pooling for database
- Implement proper caching strategies
- Monitor memory usage in goroutines
- Use context for request cancellation

## Project Structure

- Keep controllers thin, move business logic to services
- Use dependency injection
- Separate concerns (auth, business logic, data access)
- Follow clean architecture principles

## Code Quality & Linting - MANDATORY

- **Go Lint**: Use `golangci-lint` with strict configuration
- **Go Format**: Use `gofmt` and `goimports` for consistent formatting
- **Error Handling**: Always handle errors explicitly, no ignored errors
- **No Print Statements**: Remove all `fmt.Print*` statements in production code
- **Unused Variables**: Remove all unused variables and imports
- **Go Vet**: Pass `go vet` checks for common mistakes
- **Static Analysis**: Use `go mod tidy` and `go mod verify`
- **Documentation**: Document all public functions and types
- **Security**: Use `gosec` for security vulnerability scanning
- **Performance**: Avoid memory leaks and inefficient operations

## Code Review Checklist

- [ ] Function is under 30 lines
- [ ] Function name clearly describes its purpose
- [ ] All variables have descriptive names
- [ ] No generic variable names (data, result, temp, etc.)
- [ ] Boolean variables use proper prefixes
- [ ] **No magic numbers - all numeric values are named constants**
- [ ] **No magic strings - all string literals are named constants**
- [ ] **Constants are grouped logically in const blocks**
- [ ] Error handling is explicit
- [ ] Code is readable and self-documenting
- [ ] **Function is testable with dependency injection**
- [ ] **External dependencies are mockable via interfaces**
- [ ] **Function has minimal side effects**
- [ ] **Function behavior is deterministic**
- [ ] **Error conditions are easily testable**
- [ ] **Go lint passes with no errors or warnings**
- [ ] **No fmt.Print\* statements in production code**
- [ ] **No unused variables or imports**
- [ ] **Go vet checks pass**
- [ ] **go mod tidy and go mod verify pass**
- [ ] **All public functions documented**
- [ ] **Security scan passes (gosec)**
- [ ] **Performance optimizations applied**
